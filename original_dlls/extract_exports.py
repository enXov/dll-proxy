#!/usr/bin/env python3
"""
DLL Export Extractor for dll-proxy

This script extracts function exports from Windows DLL files and generates
C/C++ header files with MSVC pragma forwarding directives.

Inspired by Perfect DLL Proxy and other DLL proxy generators.

Usage:
    python extract_exports.py <dll_filename>
    python extract_exports.py version.dll
    python extract_exports.py -a  # Extract all DLLs in directory

Requirements:
    - pefile (pip install pefile)
    - Windows DLL file in the same directory
"""

import os
import sys
import argparse
from pathlib import Path

try:
    import pefile
except ImportError:
    print("Error: pefile module not found!")
    print("Install it with: pip install pefile")
    sys.exit(1)


def extract_exports(dll_path):
    """
    Extract all exports from a DLL file.
    
    Args:
        dll_path: Path to the DLL file
        
    Returns:
        List of tuples: (function_name, ordinal)
    """
    if not os.path.exists(dll_path):
        print(f"Error: File '{dll_path}' not found!")
        return None
    
    try:
        pe = pefile.PE(dll_path)
        
        if not hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            print(f"Error: '{dll_path}' has no export directory!")
            return None
        
        exports = []
        for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
            # Get function name (decode bytes to string if needed)
            if exp.name:
                func_name = exp.name.decode('utf-8') if isinstance(exp.name, bytes) else exp.name
                ordinal = exp.ordinal
                exports.append((func_name, ordinal))
        
        # Sort by ordinal for consistent output
        exports.sort(key=lambda x: x[1])
        
        return exports
    
    except pefile.PEFormatError as e:
        print(f"Error: '{dll_path}' is not a valid PE file!")
        print(f"Details: {e}")
        return None
    except Exception as e:
        print(f"Error processing '{dll_path}': {e}")
        return None


def generate_header(dll_name, exports, use_ordinals=True):
    """
    Generate C/C++ header file with MSVC pragma export forwarding.
    Uses GLOBALROOT path inspired by Perfect DLL Proxy for maximum compatibility.
    Uses macro-based approach for cleaner, more maintainable code.
    Handles three export types: regular, COM/PRIVATE, and ordinal-only.
    
    Args:
        dll_name: Name of the DLL (e.g., "version.dll")
        exports: List of tuples (function_name, ordinal)
        use_ordinals: Include ordinals in exports (default: True, recommended)
    
    Returns:
        String containing the header file content
    """
    base_name = dll_name.replace('.dll', '').upper()
    
    # Use GLOBALROOT path (inspired by Perfect DLL Proxy)
    # This is more robust than C:\Windows as it works regardless of Windows installation directory
    original_path = f"\\\\\\\\.\\\\GLOBALROOT\\\\SystemRoot\\\\System32\\\\{dll_name}"
    path_display = f"\\\\.\\GLOBALROOT\\SystemRoot\\System32\\{dll_name}"
    
    # COM functions that need PRIVATE flag (like Perfect DLL Proxy)
    com_functions = {
        'DllCanUnloadNow',
        'DllGetClassObject', 
        'DllInstall',
        'DllRegisterServer',
        'DllUnregisterServer'
    }
    
    # Categorize exports
    regular_exports = []
    private_exports = []
    ordinal_only_exports = []
    
    for func_name, ordinal in exports:
        if func_name is None:
            # Ordinal-only export (no name)
            ordinal_only_exports.append(ordinal)
        elif func_name in com_functions:
            # COM export needs PRIVATE flag
            private_exports.append((func_name, ordinal))
        else:
            # Regular named export
            regular_exports.append((func_name, ordinal))
    
    # Count export types
    ordinal_status = "with ordinals" if use_ordinals else "without ordinals"
    export_summary = f"Total Exports: {len(exports)} ({ordinal_status})"
    if private_exports:
        export_summary += f" - {len(regular_exports)} regular, {len(private_exports)} COM/PRIVATE"
        if ordinal_only_exports:
            export_summary += f", {len(ordinal_only_exports)} ordinal-only"
    elif ordinal_only_exports:
        export_summary += f" - {len(regular_exports)} regular, {len(ordinal_only_exports)} ordinal-only"
    
    header = f"""#pragma once
/*
 * Auto-generated export forwarding header for {dll_name}
 * Generated by extract_exports.py
 * Inspired by Perfect DLL Proxy (https://github.com/mrexodia/perfect-dll-proxy)
 * 
 * {export_summary}
 * Original DLL Path: {path_display}
 * Architecture: x64 only
 * 
 * Usage:
 *   #include "exports/{dll_name.replace('.dll', '')}.h"
 * 
 * This header uses MSVC #pragma directives to forward all exports
 * to the original system DLL without manual function implementation.
 * 
 * The GLOBALROOT path ensures compatibility regardless of Windows
 * installation directory and works at the NT kernel level.
 */

#ifndef {base_name}_EXPORTS_H
#define {base_name}_EXPORTS_H

// Original DLL path (GLOBALROOT for maximum compatibility)
#define ORIGINAL_DLL "{original_path}"

// Export forwarding macros (like Perfect DLL Proxy)

"""
    
    # Add appropriate macros based on use_ordinals setting
    if use_ordinals:
        header += """// Regular export: Named function with ordinal
#define MAKE_EXPORT(name, ordinal) \\
    __pragma(comment(linker, "/EXPORT:" #name "=" ORIGINAL_DLL "." #name ",@" #ordinal))

// COM export: Named function with PRIVATE flag (not in import library)
#define MAKE_EXPORT_PRIVATE(name, ordinal) \\
    __pragma(comment(linker, "/EXPORT:" #name "=" ORIGINAL_DLL "." #name ",@" #ordinal ",PRIVATE"))

// Ordinal-only export: No name, only ordinal number with NONAME flag
#define MAKE_EXPORT_ORDINAL(proxy_name, ordinal) \\
    __pragma(comment(linker, "/EXPORT:" #proxy_name "=" ORIGINAL_DLL ".#" #ordinal ",@" #ordinal ",NONAME"))

"""
    else:
        header += """// Regular export: Named function without ordinal (auto-assigned by linker)
#define MAKE_EXPORT(name, ordinal) \\
    __pragma(comment(linker, "/EXPORT:" #name "=" ORIGINAL_DLL "." #name))

// COM export: Named function with PRIVATE flag, no ordinal
#define MAKE_EXPORT_PRIVATE(name, ordinal) \\
    __pragma(comment(linker, "/EXPORT:" #name "=" ORIGINAL_DLL "." #name ",PRIVATE"))

// Ordinal-only export: Cannot be used without ordinals - skipped
#define MAKE_EXPORT_ORDINAL(proxy_name, ordinal) \\
    /* Ordinal-only exports require ordinals - this export is skipped */

"""
    
    # Add regular exports
    if regular_exports:
        header += "// Regular exports\n"
        for func_name, ordinal in regular_exports:
            header += f'MAKE_EXPORT({func_name}, {ordinal})\n'
    
    # Add COM/PRIVATE exports
    if private_exports:
        header += "\n// COM exports (PRIVATE flag)\n"
        for func_name, ordinal in private_exports:
            header += f'MAKE_EXPORT_PRIVATE({func_name}, {ordinal})\n'
    
    # Add ordinal-only exports
    if ordinal_only_exports:
        header += "\n// Ordinal-only exports (NONAME flag)\n"
        for ordinal in ordinal_only_exports:
            header += f'MAKE_EXPORT_ORDINAL(__proxy{ordinal}, {ordinal})\n'
    
    header += f"""
#endif // {base_name}_EXPORTS_H
"""
    
    return header


def save_header(dll_name, header_content, output_dir=None):
    """
    Save generated header to file.
    
    Args:
        dll_name: Name of the DLL (e.g., "version.dll")
        header_content: Generated header content
        output_dir: Directory to save header (default: ../src/exports/)
    
    Returns:
        Path to saved file
    """
    if output_dir is None:
        # Default to src/exports/ directory (one level up)
        output_dir = Path(__file__).parent.parent / "src" / "exports"
    
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    header_name = dll_name.replace('.dll', '') + '.h'
    header_path = output_dir / header_name
    
    with open(header_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    return header_path


def print_export_summary(dll_name, exports):
    """Print a summary of extracted exports."""
    print(f"\n{'='*60}")
    print(f"DLL: {dll_name}")
    print(f"{'='*60}")
    print(f"Total Exports: {len(exports)}")
    print(f"\nFirst 10 exports:")
    print(f"{'Ordinal':<10} {'Function Name'}")
    print(f"{'-'*60}")
    
    for func_name, ordinal in exports[:10]:
        print(f"{ordinal:<10} {func_name}")
    
    if len(exports) > 10:
        print(f"... and {len(exports) - 10} more")
    print(f"{'='*60}\n")


def process_dll(dll_filename, output_dir=None, verbose=True, use_ordinals=True):
    """
    Process a single DLL file: extract exports and generate header.
    
    Args:
        dll_filename: Name of DLL file to process
        output_dir: Custom output directory for header
        verbose: Print detailed information
        use_ordinals: Include ordinals in exports (default: True)
    
    Returns:
        True if successful, False otherwise
    """
    dll_path = Path(__file__).parent / dll_filename
    
    if verbose:
        print(f"Processing: {dll_filename}")
        print(f"Path: {dll_path}")
    
    # Extract exports
    exports = extract_exports(dll_path)
    if exports is None:
        return False
    
    if len(exports) == 0:
        print(f"Warning: No exports found in '{dll_filename}'")
        return False
    
    # Print summary
    if verbose:
        print_export_summary(dll_filename, exports)
    
    # Generate header
    header_content = generate_header(dll_filename, exports, use_ordinals)
    
    # Save header
    header_path = save_header(dll_filename, header_content, output_dir)
    
    if verbose:
        print(f"✓ Header generated: {header_path}")
        print(f"✓ Ready to use in CMake with -DDLL_TYPE={dll_filename.replace('.dll', '')}\n")
    
    return True


def process_all_dlls(output_dir=None, use_ordinals=True):
    """
    Process all DLL files in the original_dlls directory.
    
    Args:
        output_dir: Custom output directory for headers
        use_ordinals: Include ordinals in exports (default: True)
    
    Returns:
        Number of successfully processed DLLs
    """
    dll_dir = Path(__file__).parent
    dll_files = list(dll_dir.glob("*.dll"))
    
    if not dll_files:
        print("No DLL files found in current directory!")
        return 0
    
    print(f"Found {len(dll_files)} DLL file(s)")
    print("="*60)
    
    success_count = 0
    for dll_file in dll_files:
        if process_dll(dll_file.name, output_dir, verbose=True, use_ordinals=use_ordinals):
            success_count += 1
    
    print(f"\n{'='*60}")
    print(f"Summary: {success_count}/{len(dll_files)} DLL(s) processed successfully")
    print(f"{'='*60}\n")
    
    return success_count


def main():
    parser = argparse.ArgumentParser(
        description='Extract DLL exports and generate MSVC pragma forwarding headers',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Extract exports from specific DLL
  python extract_exports.py version.dll
  
  # Extract exports from all DLLs in directory
  python extract_exports.py -a
  
  # Extract with custom output directory
  python extract_exports.py version.dll -o /path/to/output
  
  # Quiet mode (less output)
  python extract_exports.py version.dll -q
"""
    )
    
    parser.add_argument(
        'dll_file',
        nargs='?',
        help='DLL filename to process (e.g., version.dll)'
    )
    
    parser.add_argument(
        '-a', '--all',
        action='store_true',
        help='Process all DLL files in directory'
    )
    
    parser.add_argument(
        '-o', '--output',
        metavar='DIR',
        help='Output directory for generated headers (default: ../src/exports/)'
    )
    
    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='Suppress detailed output'
    )
    
    parser.add_argument(
        '--list',
        action='store_true',
        help='List all available DLL files in directory'
    )
    
    parser.add_argument(
        '--no-ordinals',
        action='store_true',
        help='Disable ordinals in exports (not recommended, breaks ordinal-based imports)'
    )
    
    args = parser.parse_args()
    
    # List available DLLs
    if args.list:
        dll_dir = Path(__file__).parent
        dll_files = list(dll_dir.glob("*.dll"))
        if dll_files:
            print("Available DLL files:")
            for dll_file in dll_files:
                print(f"  - {dll_file.name}")
        else:
            print("No DLL files found in directory.")
        return 0
    
    # Determine ordinal usage
    use_ordinals = not args.no_ordinals
    
    # Process all DLLs
    if args.all:
        success = process_all_dlls(args.output, use_ordinals)
        return 0 if success > 0 else 1
    
    # Process single DLL
    if args.dll_file:
        success = process_dll(args.dll_file, args.output, verbose=not args.quiet, use_ordinals=use_ordinals)
        return 0 if success else 1
    
    # No arguments provided
    parser.print_help()
    return 1


if __name__ == "__main__":
    sys.exit(main())

